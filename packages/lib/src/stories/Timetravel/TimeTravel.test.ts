// https://www.martinfowler.com/bliki/GivenWhenThen.html
// 1. Данные полученные из subscribeToServerState не должны инкрементировать таймтревел
// 2. Измененный пользователем элемент списка должен быть визуально выделен(как угодно), если текущее состояние отличается от начального.
// 3. Измененный сервером элемент списка должен быть визуально выделен(как угодно), если изменение повлияло на изменения пользователем.
// 4. Показывать лог действий/изменений в любом человеко читаемом виде
// 5. При возобновлении действий и слиянии/откате изменений, должно быть возможно применить операцию "умножить на %" с и без учета нового серверного состояния.
import { TimeTravelFactory } from './TimeTravelFactory';

describe('Пользователь редактирует запись', () => {
  describe('до получения данных', () => {
    it('учитывая, что нет данных, когда я редактирую, тогда я получаю ошибку', () => {
      expect(true).toBe(true);
    });
  });
  describe('после получения данных', () => {
    it('учитывая, что есть данные, когда я редактирую, тогда я получаю новое состояние', () => {
      expect(true).toBe(true);
    });
    it('учитывая, что есть данные, когда я редактирую, тогда я могу проверить какие данные изменились', () => {
      expect(true).toBe(true);
    });
  });
});

describe('Сервер редактирует запись', () => {
  describe('до или после первого получения данных', () => {
    it('учитывая, что данные с сервера, когда они появляются, тогда пользователь не может их откатить', () => {
      expect(true).toBe(true);
    });
  });
  describe('после повторного получения данных', () => {
    it('учитывая, что пришли данные, когда есть пользовательские изменения, тогда пользователь может выбрать стратегию слияния', () => {
      expect(true).toBe(true);
    });
  });
  describe('которая дает изменения текущего состояния', () => {
    it('тогда пользователь может об этом узнать', () => {
      expect(true).toBe(true);
    });
  });
});

describe('Пользователь мержит изменения с сервером', () => {
  describe('по любой стратегии', () => {
    it('когда я сбрасываю изменения, тогда состояние совпадает с серверным', () => {
      expect(true).toBe(true);
    });
  });
  describe('по стратегии server-first', () => {
    it('когда смотрю изменения, тогда последнее состояние это состояние сервера', () => {
      expect(true).toBe(true);
    });
  });
  describe('по стратегии user-first', () => {
    it('когда я откатываю не первое изменение, тогда состояние такое же как до серверных изменений', () => {
      expect(true).toBe(true);
    });
  });
  describe('по стратегии user-replay-with-server-initial-state', () => {
    it('когда я откатываю последние изменение, тогда состояние - как, если бы до изменений состояние сервера совпадало с текущим', () => {
      expect(true).toBe(true);
    });
  });
});

describe('Действие участвует в timetravel', () => {
  describe('любое', () => {
    it('когда действие произошло, оно логгируется', () => {
      expect(true).toBe(true);
    });
    it('когда действие обратимо, тогда существует обратная операция', () => {
      expect(true).toBe(true);
    });
    it('когда действие не обратимо, тогда существует полезная нагрузка отката', () => {
      expect(true).toBe(true);
    });
    it('когда действие не применимо к другому состоянию, тогда оно должно быть заменено на действие без состояния', () => {
      expect(true).toBe(true);
    });
    it('когда действия попадают в временной интервал, тогда они объединияются в общее массовое действие', () => {
      expect(true).toBe(true);
    });
    it('когда действия одного типа идут подряд и последующая история велика, тогда они объединияются в действие того же типа', () => {
      expect(true).toBe(true);
    });
    it('когда действия объединены автоматически, тогда это понятно из истории', () => {
      expect(true).toBe(true);
    });
  });
  describe('массовое', () => {
    it('когда смотрю изменения, тогда последнее состояние это состояние сервера', () => {
      expect(true).toBe(true);
    });
  });
  describe('единичное', () => {
    it('когда я откатываю не первое изменение, тогда состояние такое же как до серверных изменений', () => {
      expect(true).toBe(true);
    });
  });
});
